{
  "master": {
    "tasks": [
      {
        "id": 26,
        "title": "Setup Project Structure and Core Dependencies",
        "description": "Initialize the project with TypeScript, React, and set up the core dependencies including react-hook-form and zod as peer dependencies.",
        "details": "1. Create a new project using a modern build tool (e.g., Vite)\n2. Configure TypeScript with strict mode enabled\n3. Set up the following dependencies:\n   - react and react-dom as peer dependencies\n   - react-hook-form as peer dependency\n   - zod as peer dependency\n   - @hookform/resolvers as direct dependency\n4. Configure package.json with appropriate entry points and exports\n5. Set up ESLint and Prettier for code quality\n6. Create the initial folder structure:\n   ```\n   src/\n     components/\n       SchemaForm.tsx\n     adapters/\n       types.ts\n       DefaultUIAdapter.ts\n       MUIAdapter.ts\n     hooks/\n     utils/\n     index.ts\n   ```\n7. Configure build process to generate both ESM and CommonJS outputs",
        "testStrategy": "1. Verify the project builds without errors\n2. Ensure TypeScript types are correctly exported\n3. Test importing the library in a sample React application\n4. Verify peer dependencies are correctly configured",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 27,
        "title": "Implement UIAdapter Interface",
        "description": "Define the UIAdapter interface that will allow different UI libraries to be plugged into the SchemaForm component.",
        "details": "1. Create a `types.ts` file in the adapters directory\n2. Define the `FieldProps` interface that all field components must accept:\n   ```typescript\n   export interface FieldProps {\n     name: string;\n     control: Control<any>;\n     label?: string;\n     placeholder?: string;\n     disabled?: boolean;\n     required?: boolean;\n     error?: FieldError;\n     [key: string]: any; // For additional props specific to component types\n   }\n   ```\n3. Define the `UIAdapter` interface:\n   ```typescript\n   export interface UIAdapter {\n     renderField: (componentType: string, props: FieldProps) => React.ReactNode;\n     // Optional methods for custom layouts\n     renderFieldLayout?: (field: React.ReactNode, label?: string, error?: string) => React.ReactNode;\n   }\n   ```\n4. Create a base abstract adapter class that can be extended by specific implementations\n5. Define standard component types: 'text', 'password', 'textarea', 'number', 'select', 'switch', etc.",
        "testStrategy": "1. Write unit tests to verify the interface definitions are complete\n2. Create a mock adapter implementation to test the interface\n3. Verify TypeScript type checking works correctly with the interface",
        "priority": "high",
        "dependencies": [
          26
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 28,
        "title": "Implement DefaultUIAdapter",
        "description": "Create the DefaultUIAdapter that renders form fields using standard HTML elements without any UI library dependencies.",
        "details": "1. Create `DefaultUIAdapter.ts` implementing the UIAdapter interface\n2. Implement rendering functions for each standard component type:\n   ```typescript\n   export const DefaultUIAdapter: UIAdapter = {\n     renderField: (componentType, props) => {\n       const { name, control, label, error, ...rest } = props;\n       \n       switch (componentType) {\n         case 'text':\n         case 'password':\n         case 'email':\n           return (\n             <Controller\n               name={name}\n               control={control}\n               render={({ field }) => (\n                 <input\n                   type={componentType}\n                   id={name}\n                   {...field}\n                   {...rest}\n                   className={error ? 'error' : ''}\n                 />\n               )}\n             />\n           );\n         case 'textarea':\n           return (\n             <Controller\n               name={name}\n               control={control}\n               render={({ field }) => (\n                 <textarea\n                   id={name}\n                   {...field}\n                   {...rest}\n                   className={error ? 'error' : ''}\n                 />\n               )}\n             />\n           );\n         // Implement other component types: select, number, checkbox, etc.\n         default:\n           return <div>Unsupported field type: {componentType}</div>;\n       }\n     },\n     renderFieldLayout: (field, label, error) => (\n       <div className=\"field-container\">\n         {label && <label htmlFor={props.name}>{label}</label>}\n         {field}\n         {error && <div className=\"error-message\">{error}</div>}\n       </div>\n     )\n   };\n   ```\n3. Add basic CSS variables for theming\n4. Implement all required standard field types",
        "testStrategy": "1. Write unit tests for each field type rendering\n2. Test error state rendering\n3. Test with various field configurations\n4. Verify accessibility of rendered elements",
        "priority": "high",
        "dependencies": [
          27
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 29,
        "title": "Implement MUIAdapter",
        "description": "Create the MUIAdapter that renders form fields using Material-UI components.",
        "details": "1. Create `MUIAdapter.ts` implementing the UIAdapter interface\n2. Add Material-UI as a peer dependency\n3. Implement rendering functions for each standard component type using MUI components:\n   ```typescript\n   export const MUIAdapter: UIAdapter = {\n     renderField: (componentType, props) => {\n       const { name, control, label, error, ...rest } = props;\n       \n       switch (componentType) {\n         case 'text':\n         case 'password':\n         case 'email':\n           return (\n             <Controller\n               name={name}\n               control={control}\n               render={({ field }) => (\n                 <TextField\n                   type={componentType}\n                   id={name}\n                   label={label}\n                   error={!!error}\n                   helperText={error?.message}\n                   fullWidth\n                   {...field}\n                   {...rest}\n                 />\n               )}\n             />\n           );\n         case 'select':\n           return (\n             <Controller\n               name={name}\n               control={control}\n               render={({ field }) => (\n                 <FormControl fullWidth error={!!error}>\n                   <InputLabel id={`${name}-label`}>{label}</InputLabel>\n                   <Select\n                     labelId={`${name}-label`}\n                     id={name}\n                     label={label}\n                     {...field}\n                     {...rest}\n                   >\n                     {props.options?.map(option => (\n                       <MenuItem key={option.value} value={option.value}>\n                         {option.label}\n                       </MenuItem>\n                     ))}\n                   </Select>\n                   {error && <FormHelperText>{error.message}</FormHelperText>}\n                 </FormControl>\n               )}\n             />\n           );\n         // Implement other component types with appropriate MUI components\n         default:\n           return <div>Unsupported field type: {componentType}</div>;\n       }\n     }\n     // No need for renderFieldLayout as MUI components handle their own layouts\n   };\n   ```\n4. Map all standard field types to appropriate MUI components",
        "testStrategy": "1. Write unit tests for each MUI component rendering\n2. Test error state rendering with MUI components\n3. Test with various field configurations\n4. Verify MUI theming integration",
        "priority": "medium",
        "dependencies": [
          27
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 30,
        "title": "Implement SchemaForm Core Component",
        "description": "Create the main SchemaForm component that takes a zod schema and renders a form using the provided UI adapter.",
        "details": "1. Create `SchemaForm.tsx` component:\n   ```typescript\n   export interface SchemaFormProps<T extends ZodType<any, any>> {\n     schema: T;\n     onSubmit: (data: z.infer<T>) => void | Promise<void>;\n     uiAdapter: UIAdapter;\n     defaultValues?: Partial<z.infer<T>>;\n     control?: Control<z.infer<T>>; // For controlled mode\n     mode?: 'onChange' | 'onBlur' | 'onSubmit' | 'onTouched' | 'all';\n   }\n\n   export function SchemaForm<T extends ZodType<any, any>>({\n     schema,\n     onSubmit,\n     uiAdapter,\n     defaultValues,\n     control: externalControl,\n     mode = 'onSubmit',\n   }: SchemaFormProps<T>) {\n     // Create form if not in controlled mode\n     const {\n       control,\n       handleSubmit,\n       formState: { errors },\n     } = externalControl\n       ? { control: externalControl, handleSubmit: () => {}, formState: { errors: {} } }\n       : useForm<z.infer<T>>({ \n           resolver: zodResolver(schema),\n           defaultValues,\n           mode,\n         });\n\n     // Extract field definitions from schema\n     const fields = extractFieldsFromSchema(schema);\n\n     return (\n       <form onSubmit={externalControl ? undefined : handleSubmit(onSubmit)}>\n         {fields.map((field) => {\n           const { path, meta, zodType } = field;\n           const componentType = getComponentTypeFromZodType(zodType, meta);\n           const error = get(errors, path);\n\n           return uiAdapter.renderFieldLayout ? (\n             uiAdapter.renderFieldLayout(\n               uiAdapter.renderField(componentType, {\n                 name: path,\n                 control,\n                 ...meta,\n                 error,\n               }),\n               meta.label,\n               error?.message\n             )\n           ) : (\n             uiAdapter.renderField(componentType, {\n               name: path,\n               control,\n               ...meta,\n               error,\n             })\n           );\n         })}\n         {!externalControl && (\n           <button type=\"submit\">Submit</button>\n         )}\n       </form>\n     );\n   }\n   ```\n2. Implement utility functions:\n   - `extractFieldsFromSchema`: Parse zod schema to extract field definitions\n   - `getComponentTypeFromZodType`: Determine appropriate component type based on zod type\n3. Handle nested objects and arrays in the schema\n4. Support both controlled and uncontrolled modes",
        "testStrategy": "1. Write unit tests for schema parsing\n2. Test form rendering with various schema types\n3. Test form submission in both controlled and uncontrolled modes\n4. Test error handling and validation\n5. Test with different UI adapters",
        "priority": "high",
        "dependencies": [
          27,
          28
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 31,
        "title": "Implement Schema Parsing Utilities",
        "description": "Create utility functions to parse zod schemas and extract field definitions, component types, and metadata.",
        "details": "1. Create utility functions in `utils/schema.ts`:\n   ```typescript\n   interface FieldDefinition {\n     path: string;\n     zodType: ZodType<any>;\n     meta: Record<string, any>;\n   }\n\n   export function extractFieldsFromSchema(schema: ZodType<any>): FieldDefinition[] {\n     const fields: FieldDefinition[] = [];\n     \n     // Handle ZodObject\n     if (schema instanceof ZodObject) {\n       const shape = schema._def.shape();\n       Object.entries(shape).forEach(([key, zodType]) => {\n         // Handle nested objects recursively\n         if (zodType instanceof ZodObject) {\n           const nestedFields = extractFieldsFromSchema(zodType).map(field => ({\n             ...field,\n             path: `${key}.${field.path}`,\n           }));\n           fields.push(...nestedFields);\n         } else {\n           fields.push({\n             path: key,\n             zodType,\n             meta: zodType._def.metadata || {},\n           });\n         }\n       });\n     }\n     \n     return fields;\n   }\n\n   export function getComponentTypeFromZodType(zodType: ZodType<any>, meta: Record<string, any>): string {\n     // Use explicit componentType from meta if provided\n     if (meta.componentType) {\n       return meta.componentType;\n     }\n     \n     // Infer from zod type\n     if (zodType instanceof ZodString) {\n       return 'text';\n     }\n     if (zodType instanceof ZodNumber) {\n       return 'number';\n     }\n     if (zodType instanceof ZodBoolean) {\n       return 'checkbox';\n     }\n     if (zodType instanceof ZodEnum || zodType instanceof ZodNativeEnum) {\n       return 'select';\n     }\n     if (zodType instanceof ZodDate) {\n       return 'date';\n     }\n     \n     // Default fallback\n     return 'text';\n   }\n   ```\n2. Add support for arrays and complex nested structures\n3. Handle special zod types like ZodEffects (refinements)\n4. Extract enum values for select options",
        "testStrategy": "1. Write comprehensive unit tests for schema parsing\n2. Test with various schema structures including nested objects and arrays\n3. Test metadata extraction\n4. Test component type inference for different zod types\n5. Test handling of custom metadata",
        "priority": "high",
        "dependencies": [
          30
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 32,
        "title": "Implement Validation and Error Handling",
        "description": "Implement validation logic using zod schemas and display error messages in the form.",
        "status": "done",
        "dependencies": [
          30,
          31
        ],
        "priority": "high",
        "details": "1. Integrate zod validation with react-hook-form using @hookform/resolvers/zod\n2. Pass error information to field components\n3. Implement error message display in adapters\n4. Support validation modes (onChange, onBlur, onSubmit)\n5. Add support for field-level validation triggers\n6. Create utility for custom error messages\n7. Support for async validation using zod's refinements\n8. Add required field indicators\n9. Enhance field components with error states\n10. Support disabled state handling during form submission",
        "testStrategy": "1. Test validation with various schema constraints\n2. Test error message display in different UI adapters\n3. Test all validation modes\n4. Test custom error messages\n5. Test field-level validation triggers\n6. Test async validation\n7. Test required field indicators\n8. Test disabled state handling during submission\n9. Investigate TypeScript type issue with Controller component",
        "subtasks": [
          {
            "id": 1,
            "title": "Create validation utilities",
            "description": "Implement validation.ts with core validation utilities",
            "status": "done",
            "dependencies": [],
            "details": "Created validation.ts with:\n- createSchemaWithCustomErrors() for custom error messages\n- transformZodErrorsToFieldErrors() for error format conversion\n- getValidationModeConfig() for validation mode support\n- createAsyncValidator() for async validation support",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Update type definitions",
            "description": "Enhance types to support validation features",
            "status": "done",
            "dependencies": [],
            "details": "Updated types/index.ts with:\n- Added ValidationMode and CustomErrorMessages types\n- Enhanced FieldProps with better error handling and UseFormStateReturn\n- Extended SchemaFormProps with validation configuration options",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Update SchemaForm component",
            "description": "Enhance SchemaForm with validation features",
            "status": "done",
            "dependencies": [],
            "details": "Updated SchemaForm component with:\n- Support for validation modes (onChange, onBlur, onSubmit, etc.)\n- Custom error messages integration\n- Async validation support\n- Better error state management\n- Submit button with loading state",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Enhance DefaultUIAdapter",
            "description": "Improve DefaultUIAdapter with error handling and styling",
            "status": "done",
            "dependencies": [],
            "details": "Enhanced DefaultUIAdapter with:\n- Improved error display for all field types\n- Required field indicators (*)\n- Better styling with error states\n- Added date and email input types\n- Disabled state handling during submission",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Investigate TypeScript type issue",
            "description": "Research and document the TypeScript type issue with Controller component",
            "status": "done",
            "dependencies": [],
            "details": "There's a TypeScript type issue with Controller component that appears to be related to React type definitions. The code compiles and works correctly, but DTS generation fails. This may need to be addressed in a future update or with different TypeScript configurations.",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 33,
        "title": "Implement Conditional Fields",
        "description": "Add support for conditionally displaying fields based on the values of other fields.",
        "details": "1. Create a utility for conditional field rendering:\n   ```typescript\n   interface ConditionalFieldProps {\n     condition: (formValues: Record<string, any>) => boolean;\n     children: React.ReactNode;\n   }\n\n   export function ConditionalField({ condition, children }: ConditionalFieldProps) {\n     const { watch } = useFormContext();\n     const formValues = watch();\n     \n     return condition(formValues) ? <>{children}</> : null;\n   }\n   ```\n2. Extend schema metadata to support display conditions:\n   ```typescript\n   // In schema definition\n   z.object({\n     accountType: z.enum(['personal', 'business']),\n     businessName: z.string().min(1).optional()\n       .meta({\n         label: 'Business Name',\n         displayCondition: (values) => values.accountType === 'business',\n       }),\n   })\n   ```\n3. Update SchemaForm to handle conditional rendering based on displayCondition\n4. Support field dependencies for conditional validation\n5. Add support for disabling fields conditionally",
        "testStrategy": "1. Test conditional rendering with various conditions\n2. Test conditional validation\n3. Test interaction between multiple conditional fields\n4. Test performance with many conditional fields\n5. Test edge cases like circular dependencies",
        "priority": "medium",
        "dependencies": [
          31,
          32
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 34,
        "title": "Implement Custom Component Support",
        "description": "Add support for using custom components in the form schema.",
        "details": "1. Extend the schema metadata to support custom components:\n   ```typescript\n   // In schema definition\n   z.object({\n     birthDate: z.date()\n       .meta({\n         component: DatePickerComponent,\n         componentProps: {\n           format: 'yyyy-MM-dd',\n           disableFuture: true,\n         },\n       }),\n   })\n   ```\n2. Update the UIAdapter interface to handle custom components:\n   ```typescript\n   export interface UIAdapter {\n     renderField: (componentType: string, props: FieldProps) => React.ReactNode;\n     renderCustomComponent?: (Component: React.ComponentType<any>, props: FieldProps) => React.ReactNode;\n     renderFieldLayout?: (field: React.ReactNode, label?: string, error?: string) => React.ReactNode;\n   }\n   ```\n3. Implement default custom component rendering in adapters\n4. Add type safety for custom component props\n5. Support for complex custom components with their own state management",
        "testStrategy": "1. Test rendering of custom components\n2. Test prop passing to custom components\n3. Test integration with form validation\n4. Test with various custom component libraries\n5. Test performance with complex custom components",
        "priority": "medium",
        "dependencies": [
          30,
          31
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 35,
        "title": "Implement Layout Customization and CSS Variables",
        "description": "Add support for customizing field layouts and implement CSS variables for theming.",
        "details": "1. Implement the renderFieldLayout function in adapters:\n   ```typescript\n   renderFieldLayout: (field, label, error) => (\n     <div className=\"sf-field-container\">\n       {label && <label className=\"sf-field-label\">{label}</label>}\n       <div className=\"sf-field-input\">{field}</div>\n       {error && <div className=\"sf-field-error\">{error}</div>}\n     </div>\n   )\n   ```\n2. Allow overriding the layout at the form level:\n   ```typescript\n   <SchemaForm\n     schema={schema}\n     onSubmit={handleSubmit}\n     uiAdapter={defaultAdapter}\n     renderFieldLayout={(field, label, error) => (\n       <MyCustomLayout field={field} label={label} error={error} />\n     )}\n   />\n   ```\n3. Define CSS variables for theming:\n   ```css\n   :root {\n     --sf-color-primary: #1976d2;\n     --sf-color-error: #d32f2f;\n     --sf-color-text: #333333;\n     --sf-color-label: #666666;\n     --sf-font-family: 'Roboto', sans-serif;\n     --sf-border-radius: 4px;\n     --sf-spacing-unit: 8px;\n     /* Additional variables */\n   }\n\n   .sf-field-container {\n     margin-bottom: calc(var(--sf-spacing-unit) * 2);\n     font-family: var(--sf-font-family);\n   }\n\n   .sf-field-label {\n     color: var(--sf-color-label);\n     margin-bottom: var(--sf-spacing-unit);\n     display: block;\n   }\n\n   .sf-field-error {\n     color: var(--sf-color-error);\n     font-size: 0.875rem;\n     margin-top: var(--sf-spacing-unit);\n   }\n   ```\n4. Document all available CSS variables\n5. Provide helper functions for programmatic theme customization",
        "testStrategy": "1. Test custom layouts with various configurations\n2. Test CSS variable overrides\n3. Test layout responsiveness\n4. Test accessibility of custom layouts\n5. Test integration with design systems",
        "priority": "medium",
        "dependencies": [
          28,
          29,
          30
        ],
        "status": "done",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-06-24T07:12:13.472Z",
      "updated": "2025-06-27T03:18:02.880Z",
      "description": "Tasks for master context"
    }
  }
}